var Physics={element:null,defaultSpaceChar:" ",defaultShapeChar:"*",defaultNewlineChar:"<br>",startString:"PHYV5:<br><br>",gravitationalConstant:0.2,frictionConstant:0.7,terminalVelocity:7,ticksPerSecond:60,updatesPerSecond:40,renderPerSecond:50,renderInColor:!1,now:Date.now(),nextTick:Date.now(),nextUpdate:Date.now(),nextRender:Date.now(),lastUpdate:Date.now(),oldDelta:0,enableDeltaTimeCalculations:!0,simpleDeltaCalculations:!0,forceAverageDelta:!1,moreEfficientPhysics:!1,debugMode:!1,allGravity:!1,width:window.innerWidth,height:window.innerHeight,lineHeight:0.65,initialLineHeight:0.83,collisionAccuracy:0.5,collisionEfficiency:-1,inefficientArr:[],bodyFontSize:16,renderBuffer:[],renderString:[],charsPerFrame:0,renderLoopPasts:[],renderLoopNext:0,renderLoopShapes:[],shape:function(type,options){if(type===undefined||options===undefined){throw new Error("Type or options incomplete when constructing shape");return new Error("")}else{this.x=options.x||0;this.y=options.y||0;this.mesh=[];this.colorMesh=[];this.shapeArrayNum=Physics.renderLoopShapes.length;Physics.renderLoopShapes[Physics.renderLoopShapes.length]=this;this.color=options.color||"black";if(typeof this.color==="undefined"){this.color="black"}
this.UUID=generateUUID();this.gravity=options.gravity||!1;if(typeof this.gravity==="undefined"||typeof options.gravity==="undefined"){this.gravity=!1}
this.momentumX=0;this.momentumY=0;this.collide=options.collide;if(typeof this.collide==="undefined"){this.collide=!0}
this.overrideRenderLimit=options.overrideRenderLimit||!1;if(typeof this.overrideRenderLimit==="undefined"){this.overrideRenderLimit=!1}
this.pointTable=[];this.updPointTable=[];this.collisionBottom=!1;this.collisionTop=!1;this.collisionRight=!1;this.collisionLeft=!1;this.character=options.character||Physics.defaultShapeChar;if(this.character.length>1){this.character=this.character.substring(0,1)}
this.type=type;if(type=="box"){this.height=options.height||10;this.width=options.width||10;this.filled=options.filled;if(typeof this.filled==="undefined"){this.filled=!0}
if(this.filled){for(var i=0;i<this.height;i++){this.mesh[i]="";this.colorMesh[i]="";for(var j=0;j<this.width;j++){this.mesh[i]+=this.character;this.colorMesh[i]+="<span style='color: "+this.color+";'>"+this.character+"</span>";this.pointTable[this.pointTable.length]=[i,j]}}}else{for(var i=0;i<this.height;i++){this.mesh[i]="";this.colorMesh[i]="";for(var j=0;j<this.width;j++){if((i==0||i==(this.height-1))||(j==0||j==(this.width-1))){this.mesh[i]+=this.character;this.colorMesh[i]+="<span style='color: "+this.color+";'>"+this.character+"</span>";this.pointTable[this.pointTable.length]=[i,j]}else{this.mesh[i]+=Physics.defaultSpaceChar;this.colorMesh[i]+=Physics.defaultSpaceChar}}}}}else if(type=="line"){this.length=options.length||10;this.mesh[0]="";for(var i=0;i<this.length;i++){this.mesh[0]+=this.character;this.colorMesh[0]+="<span style='color: "+this.color+";'>"+this.character+"</span>";this.pointTable[this.pointTable.length]=[i,0]}}else if(type=="triangle"){this.height=options.height||options.width/2;this.width=options.width||options.height*2;for(var i=0;i<this.height;i++){this.mesh[i]="";this.colorMesh[i]="";for(var j=0;j<this.width;j++){this.mesh[i]+=Physics.defaultSpaceChar;this.colorMesh[i]+=Physics.defaultSpaceChar}}
var start=this.width/2;var amount=1;for(var i=0;i<this.height;i++){for(var j=0;j<amount;j++){this.mesh[i]=this.mesh[i].replaceAt((start+j),this.character);this.colorMesh[i]=this.mesh[i].replaceAt((start+j),"<span style='color: "+this.color+";'>"+this.character+"</span>");this.pointTable[this.pointTable.length]=[i,j]}
start-=1;amount+=2}}else if(type=="custom"){if(typeof options.mesh==="undefined"||typeof options.mesh!=="object"){console.error("Mesh for custom object is undefined")}else{this.width=0;this.height=options.mesh.length;for(var i=0;i<options.mesh.length;i++){this.mesh[i]=[];this.colorMesh[i]=[];if(options.mesh[i].length>this.width){this.width=options.mesh[i].length}
for(var j=0;j<options.mesh[i].length;j++){this.mesh[i]+=options.mesh[i][j];if(options.mesh[i][j]==" "){this.colorMesh[i]+=" "}else{this.colorMesh[i]+="<span style='color: "+this.color+";'>"+options.mesh[i][j]+"</span>"}
this.pointTable[this.pointTable.length]=[i,j]}}}}else if(type=="circle"){this.radius=options.radius||10;this.filled=options.filled||!1;if(this.filled==!0){var centerx=this.radius;var centery=this.radius;for(var i=0;i<=2*this.radius;i++){this.mesh[i]="";this.colorMesh[i]="";for(var j=0;j<=2*this.radius;j++){var offsetx=j;var offsety=i;var dx=centerx-offsetx;var dy=centery-offsety;if((dx*dx+dy*dy)<=(this.radius*this.radius)){this.mesh[i]+=this.character;this.colorMesh[i]+="<span style='color: "+this.color+";'>"+this.character+"</span>";this.pointTable[this.pointTable.length]=[i,j]}else{this.mesh[i]+=Physics.defaultSpaceChar;this.colorMesh[i]+=Physics.defaultSpaceChar}}}}else if(this.filled=="cool"){for(var i=0;i<=2*this.radius;i++){this.mesh[i]="";this.colorMesh[i]="";for(var j=0;j<=2*this.radius;j++){var distance=Math.sqrt((i-this.radius)*(i-this.radius)+(j-this.radius)*(j-this.radius));if(distance>this.radius-0.5&&distance<this.radius+0.5){this.pointTable[this.pointTable.length]=[i,j];this.mesh[i]+=this.character;this.colorMesh[i]+="<span style='color: "+this.color+";'>"+this.character+"</span>"}else{this.mesh[i]+=Physics.defaultSpaceChar;this.colorMesh[i]+=Physics.defaultSpaceChar}}}
var xoff=0;var yoff=0;var range=this.radius*Math.sin(45);for(var i=xoff-range+1;i<xoff+range;i++){for(var j=yoff-range+1;j<yoff+range;j++){var roux=Math.round(i)+this.radius;var rouy=Math.round(j)+this.radius;this.pointTable[this.pointTable.length]=[i,j];this.mesh[rouy]=this.mesh[rouy].replaceAt(roux,this.character);this.colorMesh[rouy]=this.colorMesh[rouy].replaceAt(roux,"<span style='color: "+this.color+";'>"+this.character+"</span>")}}}else{for(var i=0;i<=2*this.radius;i++){this.mesh[i]="";this.colorMesh[i]="";for(var j=0;j<=2*this.radius;j++){var distance=Math.sqrt((i-this.radius)*(i-this.radius)+(j-this.radius)*(j-this.radius));if(distance>this.radius-0.5&&distance<this.radius+0.5){this.mesh[i]+=this.character;this.colorMesh[i]+="<span style='color: "+this.color+";'>"+this.character+"</span>";this.pointTable[this.pointTable.length]=[i,j]}else{this.mesh[i]+=Physics.defaultSpaceChar;this.colorMesh[i]+=Physics.defaultSpaceChar}}}}}else{console.error("Shape not found. There may be errors rendering.")}
this.pointTable.uniqueify();this.update()}},render:function(clearScreen){if(typeof clearScreen==="undefined"){clearScreen=!1}
Physics.now=Date.now();var elapsed=Physics.now-Physics.nextRender;var nextFrameReached=(elapsed>(1000/Physics.renderPerSecond))?!0:!1;if(nextFrameReached){Physics.nextRender=Physics.now-(elapsed%(1000/Physics.renderPerSecond))}
var elapsedupd=Physics.now-Physics.nextUpdate;var nextUpdateReached=(elapsedupd>(1000/Physics.updatesPerSecond))?!0:!1;if(nextUpdateReached){Physics.nextUpdate=Physics.now-(elapsedupd%(1000/Physics.updatesPerSecond))}
Physics.charsPerFrame=0;if(clearScreen){Physics.renderBuffer=[];for(var j=0;j<Physics.height;j++){Physics.renderBuffer[j]="";for(var i=0;i<Physics.width;i++){Physics.renderBuffer[j]+=Physics.defaultSpaceChar}}}
var colorXOffset=[];var rtolRender=[];if(Physics.renderInColor){for(var i=0;i<arguments.length;i++){}}
for(var i=0;i<arguments.length;i++){if(arguments[i]!=!0&&arguments[i]!=!1&&typeof arguments[i]!=="undefined"){try{if((arguments[i].gravity==!0||Physics.allGravity)&&(nextUpdateReached||!0)){if(Physics.debugMode){console.log("Updating velocity for shape: "+arguments[i].type+", UUID: "+arguments[i].UUID+" (velX: "+arguments[i].momentumX+", velY: "+arguments[i].momentumY+")")}
arguments[i].update(!1)}}catch(e){console.error("Error updating gravity for shape. Shape: "+arguments[i]+", e: "+e)}
if(arguments[i].UUID===undefined){if(!(i==0&&(arguments[i]==!0||arguments[i]==!1))){console.error("Error drawing: argument "+i+" does not exist or doesn't have a UUID")}}else{var bad=!1;try{arguments[i].width=arguments[i].mesh[0].length;arguments[i].height=arguments[i].mesh.length}catch(e){bad=!0;console.error("Error rendering: argument "+i+" doesn't have a width or height property")}
if((arguments[i].width>Physics.width||arguments[i].height>Physics.height)&&arguments[i].type!="colorbox"){bad=!0;console.error("Error rendering: argument "+i+"'s mesh is too large to fit on screen")}
if(bad==!1){var x=constrain(arguments[i].x,0,(Physics.width-arguments[i].width));var y=constrain(arguments[i].y,0,(Physics.height-arguments[i].height));arguments[i].x=x;arguments[i].y=y;x=Math.round(x);y=Math.round(y);if(Physics.debugMode){console.info("Shape to be placed at x: "+x+", y: "+y)}
if(arguments[i].mesh.length==0||arguments[i].colorMesh.length==0){console.error("Error rendering: shape has no mesh (or colorMesh) to render!")}else{if(nextFrameReached||clearScreen==!1||arguments[i].overrideRenderLimit||!0){var mesh=(Physics.renderInColor)?arguments[i].colorMesh:arguments[i].mesh;for(var j=0;j<mesh.length;j++){if(Physics.renderInColor){Physics.renderBuffer[j+y]=Physics.renderBuffer[j+y].slice(0,x)+arguments[i].colorMesh[j]+Physics.renderBuffer[j+y].slice(x);var endX=arguments[i].x+arguments[i].colorMesh[j].length;Physics.charsPerFrame+=arguments[i].colorMesh[j].length;if(Physics.debugMode){console.log("Adding to buffer (COLOR) at x: "+(x)+", y: "+(j+y)+", offset: "+JSON.stringify(colorXOffset)+", j val: "+j+", chars: "+arguments[i].colorMesh[j])}}else{for(var b=0;b<mesh[j].length;b++){try{Physics.renderBuffer[j+y]=Physics.renderBuffer[j+y].replaceAt(b+x,arguments[i].mesh[j][b]);Physics.charsPerFrame++}catch(e){console.error("Error while rendering physics buffer for shape "+arguments[i].type+", UUID "+arguments[i].UUID+", x: "+(b+x)+", y: "+(j+y)+", error: "+e)}
if(Physics.debugMode){console.log("Adding to buffer (non-color) at x: "+(b+x)+", offset: "+JSON.stringify(colorXOffset)+", j val: "+j+", y: "+(j+y)+", char: "+mesh[j][b])}}}}}}}}}}
var temp=Physics.startString;for(var i=0;i<Physics.renderBuffer.length;i++){temp+=Physics.renderBuffer[i]+Physics.defaultNewlineChar}
if(Physics.charsPerFrame>0){if(Physics.element.innerHTML!=temp){Physics.renderString=Physics.startString;for(var i=0;i<Physics.renderBuffer.length;i++){Physics.renderString+=Physics.renderBuffer[i]+Physics.defaultNewlineChar}
Physics.element.innerHTML=Physics.renderString}}},calculate_collisions:function(){if(arguments.length<2){console.error("Error while calculating collisions: there is only one (or none) shape passed into function. COLL_MAIN")}else{Physics.now=Date.now();var elapsed=Physics.now-Physics.nextTick;var nextTickReached=(elapsed>(1000/Physics.ticksPerSecond))?!0:!1;if(nextTickReached){Physics.nextTick=Physics.now-(elapsed%(1000/Physics.ticksPerSecond))}
if(nextTickReached){var inefficient=0;Physics.inefficientArr=[];for(var i=0;i<arguments.length;i++){arguments[i].collisionBottom=!1;arguments[i].collisionTop=!1;arguments[i].collisionRight=!1;arguments[i].collisionLeft=!1}
for(var i=0;i<arguments.length;i++){arguments[i].calculate();for(var j=1;j<arguments.length-1;j++){if(j==1){arguments[j].calculate()}
if(typeof arguments[i]!="undefined"&&typeof arguments[j]!="undefined"){if(arguments[i]!==arguments[j]){if(Physics.debugMode){console.log("Arguments evaluating for collision type: "+arguments[i].type+" "+arguments[j].type)}
switch((Physics.moreEfficientPhysics)?(arguments[i].type+" "+arguments[j].type):("nomatch")){case "box box":if(arguments[i].x<arguments[j].x+arguments[j].width&&arguments[i].x+arguments[i].width>arguments[j].x&&arguments[i].y<arguments[j].y+arguments[j].height&&arguments[i].height+arguments[i].y>arguments[j].y){Physics.determineCollisionSide(arguments[i],arguments[j])}
break;case "line box":if(arguments[i].x<arguments[j].x+arguments[j].width&&arguments[i].x+arguments[i].length>arguments[j].x&&arguments[i].y<arguments[j].y+arguments[j].height&&1+arguments[i].y>arguments[j].y){Physics.determineCollisionSide(arguments[i],arguments[j])}
break;case "box line":if(arguments[i].x<arguments[j].x+arguments[j].length&&arguments[i].x+arguments[i].width>arguments[j].x&&arguments[i].y<arguments[j].y+1&&arguments[i].height+arguments[i].y>arguments[j].y){Physics.determineCollisionSide(arguments[i],arguments[j])}
break;case "line line":if(arguments[i].x<arguments[j].x+arguments[j].length&&arguments[i].x+arguments[i].length>arguments[j].x&&arguments[i].y<arguments[j].y+1&&1+arguments[i].y>arguments[j].y){Physics.determineCollisionSide(arguments[i],arguments[j])}
break;case "circle circle":break;case "line circle":break;case "circle line":break;case "box circle":break;case "circle box":break;default:inefficient++;Physics.inefficientArr[Physics.inefficientArr.length]=arguments[i];Physics.inefficientArr[Physics.inefficientArr.length]=arguments[j];break}}}}}
for(var i=0;i<Physics.inefficientArr.length;i+=2){if(typeof Physics.inefficientArr[i]!="undefined"&&typeof Physics.inefficientArr[i+1]!="undefined"){Physics.calculate_collisions_narrow(Physics.inefficientArr[i],Physics.inefficientArr[i+1])}else{console.error("COLL_NARROW: Physics coll i+1 val missing, calculating with previous argument");Physics.calculate_collisions_narrow([i],Physics.inefficientArr[i-1])}}
if(Physics.debugMode){console.log("Physics collision checking ineffifiency: "+((inefficient/(arguments.length**2))*100)+"%, inefficiently processed args: "+inefficient+", args: "+arguments.length)}
Physics.collisionEfficiency=100-((inefficient/(arguments.length**2))*100)}}},calculate_collisions_mid:function(){},calculate_collisions_narrow:function(){if(arguments.length<2){console.error("Error while calculating collisions: there is only one (or none) shape passed into function. COLL_NARROW")}else{for(var i=0;i<arguments.length;i++){for(var j=1;j<arguments.length;j++){for(var b=0;b<arguments[i].updPointTable.length;b++){for(var z=0;z<arguments[j].updPointTable.length;z++){var xdist=(arguments[i].updPointTable[b][0]-arguments[j].updPointTable[z][0]);var ydist=(arguments[i].updPointTable[b][1]-arguments[j].updPointTable[z][1]);if(((xdist>-Physics.collisionAccuracy&&xdist<Physics.collisionAccuracy)&&(ydist>-Physics.collisionAccuracy&&ydist<Physics.collisionAccuracy))&&arguments[i].UUID!=arguments[j].UUID){if(Physics.debugMode){console.log("Collision detected between "+arguments[i].type+" (UUID: "+arguments[i].UUID+") and "+arguments[j].type+" (UUID: "+arguments[j].UUID+"), X1: "+arguments[i].updPointTable[b][0]+", Y1: "+arguments[i].updPointTable[b][1]+", X2: "+arguments[j].updPointTable[z][0]+", Y2: "+arguments[j].updPointTable[z][0])}
Physics.determineCollisionSideFromPoint(arguments[i],arguments[j],b,z)}}}}}}},determineCollisionSideFromPoint:function(shape,shape2,shape1ind,shape2ind){if(shape.collide){if(shape.collisionRight==!1&&shape.collisionLeft==!1){if(shape.updPointTable[shape1ind][0]<=shape.centerPoint[0]){shape.collisionRight=!1;shape.collisionLeft=!0}else if(shape.updPointTable[shape1ind][0]>shape.centerPoint[0]){shape.collisionRight=!0;shape.collisionLeft=!1}else{console.error("Error calculating collision side from collision (x axis), try running update on shape "+shape.type+", UUID "+shape.UUID);shape.calculate()}}
if(shape.collisionTop==!1&&shape.collisionBottom==!1){if(shape.updPointTable[shape1ind][1]<=shape.centerPoint[1]||shape.y+shape.height==Physics.height){shape.collisionBottom=!0;shape.collisionTop=!1}else if(shape.updPointTable[shape1ind][1]>shape.centerPoint[1]){shape.collisionBottom=!1;shape.collisionTop=!0}else{console.error("Error calculating collision side from collision (y axis), try running update on shape "+shape.type+", UUID "+shape.UUID);shape.calculate()}}}
if(shape2.collide){if(shape2.collisionRight==!1&&shape2.collisionLeft==!1){if(shape2.updPointTable[shape2ind][0]<=shape2.centerPoint[0]){shape2.collisionRight=!1;shape2.collisionLeft=!0}else if(shape2.updPointTable[shape2ind][0]>shape2.centerPoint[0]){shape2.collisionRight=!0;shape2.collisionLeft=!1}else{console.error("Error calculating collision side from collision (x axis), try running update on shape "+shape2.type+", UUID "+shape2.UUID+"Point X: "+shape2.updPointTable[shape1ind][0]+", center X: "+shape2.centerPoint[0]);shape2.calculate()}}
if(shape2.collisionTop==!1&&shape2.collisionBottom==!1){if(shape2.updPointTable[shape2ind][1]<=shape2.centerPoint[1]||shape2.y+shape2.height==Physics.height){shape2.collisionBottom=!0;shape2.collisionTop=!1}else if(shape2.updPointTable[shape2ind][1]>shape2.centerPoint[1]){shape2.collisionBottom=!1;shape2.collisionTop=!0}else{console.error("Error calculating collision side from collision (y axis), try running update on shape "+shape2.type+", UUID "+shape2.UUID);shape2.calculate()}}}
if(Physics.debugMode){console.log("Shape 1 updPointTable "+JSON.stringify(shape.updPointTable[shape1ind])+", Shape 2 updPointTable "+JSON.stringify(shape2.updPointTable[shape2ind])+", Shape 1 centerPoint "+JSON.stringify(shape.centerPoint)+", Shape 2 centerPoint "+JSON.stringify(shape2.centerPoint)+", Shape 1 collide "+shape.collide+", Shape 2 collide "+shape2.collide)}},determineCollisionSide:function(shape1,shape2){if(shape1.centerPoint[0]<=shape2.centerPoint[0]){shape1.collisionLeft=!0;shape1.collisionRight=!1;shape2.collisionRight=!0;shape2.collisionLeft=!1}
if(shape1.centerPoint[0]<=shape2.centerPoint[0]){shape1.collisionBottom=!0;shape1.collisionTop=!1;shape2.collisionTop=!0;shape2.collisionBottom=!1}},init:function(){setTimeout(function(){console.typeable("debugon","console.log(\"Type debugon into the console to enable debug mode. (Warning: there is about 1000 debug messages outputted per second)\");","console.log(\"Debug mode active.\"); Physics.debugMode = true;");console.typeable("debugoff","console.log(\"Type debugoff into the console to disable debug mode.\");","console.log(\"Debug mode disabled.\"); Physics.debugMode = false;");console.typeable("collisioncheck","console.log(\"Type collisioncheck into the console to test collisions. (mostly for me) Note that the object being tested must be named \'player\'.\");","console.log(\"Testing collisions...\"); player.y = 1000; player.x = -1000; Physics.render(platform,platform2,platform3,player,tri); Physics.calculate_collisions(platform,platform2,platform3,player,tri); console.log(\"Player colliding: bottom: \"+player.collisionBottom+\", top: \"+player.collisionTop+\", right: \"+player.collisionRight+\", left: \"+player.collisionLeft); setTimeout(function(){player.y = 10; player.x = 10; Physics.render(platform,platform2,platform3,player,tri); Physics.calculate_collisions(platform,platform2,platform3,player,tri); console.log(\"Player still colliding: bottom: \"+player.collisionBottom+\", top: \"+player.collisionTop+\", right: \"+player.collisionRight+\", left: \"+player.collisionLeft);},100);");console.typeable("debug2s","console.log('Type debug2s into the console to perform auto-test of code for 2s and then stop it. (Mostly for debugging broken things in render loop)');","console.clear(); fpsInterval = 0; debugon; setFPS(1); setTimeout(function(){fpsInterval = 0; debugoff;},2000);")},500);Physics.element.style.lineHeight=String(Physics.lineHeight);Physics.height=Math.round(window.innerHeight*(Physics.lineHeight-0.53));Physics.width=Math.round(window.innerWidth*(Physics.lineHeight-0.523));Physics.bodyFontSize=parseFloat(window.getComputedStyle(document.body,null).getPropertyValue('font-size'))},clear:function(){Physics.renderBuffer=[];Physics.collisionBuffers=[];Physics.element.innerHTML=""},renderLoop:function(opts){var args=arguments;opts.fps=opts.fps||60;if(typeof opts.collision=="undefined"){opts.collision=!0}
if(typeof opts.onFrame=="undefined"){opts.onFrame=function(){};opts.executeOnFrame=!1}else{opts.executeOnFrame=!0}
if(typeof opts.clear=="undefined"){opts.clear=!0}
opts.queueNum=Physics.renderLoopNext;Physics.renderLoopPasts[opts.queueNum]=Date.now();this.options=opts;var _this=this;this._this=this;this.args=args;this.firstRun=!0;function createRenderLoop(_this,queuenum,args){_this.loopNum=setInterval(function(){var fpsInterval=1000/_this.options.fps;var now=Date.now();var then=Physics.renderLoopPasts[queuenum];var elapsed=now-then;if(elapsed>fpsInterval){Physics.renderLoopPasts[queuenum]=now-(elapsed%fpsInterval);var renderstr="Physics.render("+_this.options.clear+",";var firstrunstr;if(_this.firstRun){var firstrunstr="Physics.render(true,"}
var collisionstr="Physics.calculate_collisions(";for(var i=1;i<args.length;i++){if(Physics.debugMode){console.log("args into renderloop i: "+i+", arg: "+JSON.stringify(args[i]))}
renderstr+="Physics.renderLoopShapes["+args[i].shapeArrayNum+"],";if(_this.firstRun){firstrunstr+="Physics.renderLoopShapes["+args[i].shapeArrayNum+"],"}
collisionstr+="Physics.renderLoopShapes["+args[i].shapeArrayNum+"],"}
renderstr=renderstr.substring(0,renderstr.length-1);collisionstr=collisionstr.substring(0,collisionstr.length-1);if(_this.firstRun){firstrunstr=firstrunstr.substring(0,firstrunstr.length-1);firstrunstr+=");";console.log(firstrunstr)
eval(firstrunstr);_this.firstRun=!1}
renderstr+=");";collisionstr+=");";if(Physics.debugMode){console.log(renderstr)}
eval(renderstr);if(_this.options.collision){eval(collisionstr)}
if(_this.options.executeOnFrame){try{_this.options.onFrame()}catch(e){_this.options.executeOnFrame=!1;console.error("Error executing onFrame function for renderLoop. E: "+e+", RENDERLOOP_LOOP")}}}},0)}
this.start=function(){createRenderLoop(this,this.options.queueNum,this.args)}
this.stop=function(){try{clearInterval(this.loopNum)}catch(e){console.error("Error stopping renderLoop. E: "+e+", RENDERLOOP_MAIN")}}
Physics.renderLoopNext++}}
Physics.shape.prototype.update=function(render){this.calculate();var deltaTime=(Physics.forceAverageDelta)?((Physics.oldDelta+((Date.now()-Physics.lastUpdate)/(1000/Physics.updatesPerSecond)))/2):(Date.now()-Physics.lastUpdate)/(1000/Physics.updatesPerSecond);Physics.oldDelta=deltaTime;var frictionRatio=1/(0.3+(deltaTime*Physics.frictionConstant));var gravityRatio=1/(0.7+(deltaTime*Physics.gravitationalConstant));render=render||!1;if(this.gravity===undefined||this.momentumX===undefined||this.momentumY===undefined){console.error("Object passed in to update function has no gravity constants")}else{if(this.gravity||Physics.allGravity){this.momentumX=constrain(this.momentumX,-Physics.terminalVelocity,Physics.terminalVelocity);this.momentumY=constrain(this.momentumY,-Physics.terminalVelocity,Physics.terminalVelocity);if(this.y+this.height==Physics.height){this.momentumY=0}
if(this.x+this.width==Physics.width){this.momentumX=0}
var gconst=0.99;var fconst=0.99;this.y+=((Physics.enableDeltaTimeCalculations)?((!Physics.simpleDeltaCalculations)?(this.momentumY*(gconst**(deltaTime*deltaTime)-1)/(deltaTime*Math.log(gconst))):(this.momentumY*deltaTime)):this.momentumY);this.x+=((Physics.enableDeltaTimeCalculations)?((!Physics.simpleDeltaCalculations)?(this.momentumX*(fconst**(deltaTime*deltaTime)-1)/(deltaTime*Math.log(fconst))):(this.momentumX*deltaTime)):this.momentumX);if(Physics.debugMode){console.log("Complex calculations for x pos change: "+String((this.momentumX*(fconst**(deltaTime*deltaTime)-1)/(deltaTime*Math.log(fconst))))+" Simple calculations for x pos change: "+(this.momentumX*deltaTime));console.log("Complex calculations for y pos change: "+String((this.momentumY*(gconst**(deltaTime*deltaTime)-1)/(deltaTime*Math.log(gconst))))+" Simple calculations for y pos change: "+(this.momentumY*deltaTime));console.log("Δtime: "+deltaTime)}
if(this.collisionBottom||this.collisionTop){this.momentumY=-0.25}else{if(this.momentumY<=Physics.terminalVelocity||this.momentumY>=-Physics.terminalVelocity){this.momentumY=this.momentumY+Physics.gravitationalConstant}
if(this.collisionRight||this.collisionLeft){this.momentumX=0}}
if(this.momentumX<Physics.frictionConstant&&this.momentumX>-Physics.frictionConstant){this.momentumX=0}
if(this.momentumY<Physics.gravitationalConstant&&this.momentumY>Physics.gravitationalConstant){this.momentumY=0}
if(this.collisionRight==!1||this.collisionLeft==!1){if(this.momentumX<=Physics.terminalVelocity&&this.momentumX>=-Physics.terminalVelocity){if(this.momentumX>0){this.momentumX=this.momentumX-Physics.frictionConstant}else if(this.momentumX<0){this.momentumX=this.momentumX+Physics.frictionConstant}}}}
if(this.height+this.y==Physics.height){this.momentumY=-2}}
Physics.lastUpdate=Date.now();if(render){Physics.render(!1,this)}}
Physics.shape.prototype.calculate=function(){if(this.pointTable===undefined||this.updPointTable===undefined){console.error("No point table or updatePointTable object found")}else{this.updPointTable=[];for(var i=0;i<this.pointTable.length;i++){this.updPointTable[i]=[];if(this.pointTable[i].length==2){this.updPointTable[i][0]=this.pointTable[i][0]+this.x;this.updPointTable[i][1]=this.pointTable[i][1]+this.y}else{console.error("Point table i:"+i+" has an invalid point length, not 2")}}}
this.centerPoint=[(this.updPointTable[0][0]+(0.5*(this.width||this.radius||this.length||this.height||0))),(this.updPointTable[0][1]+(0.5*(this.height||this.radius||this.length||this.width||0)))]}
Physics.shape.prototype.regenColorMesh=function(newColor){this.colorMesh=[];this.color=newColor;for(var i=0;i<this.mesh.length;i++){this.colorMesh[i]="";for(var j=0;j<this.mesh[i].length;j++){if(this.type=="custom"&&this.mesh[i][j]!==" "){this.colorMesh[i]+="<span style='color: "+this.color+";'>"+this.mesh[i][j]+"</span>"}else if(this.mesh[i][j]==this.character){this.colorMesh[i]+="<span style='color: "+this.color+";'>"+this.character+"</span>"}else{this.colorMesh[i]+=Physics.defaultSpaceChar}}}}
var play=[];var timeSinceUpKey;var timeBetweenJumps=900;var lastKeyPress=Date.now();var map={};Physics.shape.prototype.control=function(){play=this;window.onkeydown=window.onkeyup=function(e){var e=window.event?window.event:e;map[e.keyCode]=e.type=='keydown';if(map["37"]||map["38"]||map["39"]||map["40"]){e.preventDefault()}
if(map["38"]){timeSinceUpKey=Date.now()-lastKeyPress;if(play.momentumY<Physics.gravitationalConstant&&timeSinceUpKey>timeBetweenJumps){lastKeyPress=Date.now();play.y-=2;setTimeout(function(){play.momentumY=-3},50)}else if(lvlnum==0||lvlnum=="title"){play.momentumY=-2.5}}
if(map["40"]){if(play.y+play.height==Physics.height||play.momentumY<Physics.gravitationalConstant){play.momentumY=3}else if(lvlnum==0||lvlnum=="title"){play.momentumY=3}}
if(map["37"]){if(play.momentumX<Physics.terminalVelocity&&play.momentumX>-Physics.terminalVelocity){play.momentumX=-3}}
if(map["39"]){if(play.momentumX<Physics.terminalVelocity&&play.momentumX>-Physics.terminalVelocity){play.momentumX=3}}}}